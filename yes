odd even transposition sort:
#include<stdio.h>
#define n 8
_global_ void sort(int *a){
int i=threadIdx.x;
for(int j=0;j<n;j++){
if(j%2==0 && (i*2+1)<n){
if(a[2*i]>a[2*i+1]){
int temp=a[2*i];
a[2*i]=a[2*i+1];
a[2*i+1]=temp;
}
}
if(j%2==1 && (2*i+2)<n){
if(a[2*i+1]>a[2*i+2]){
int temp=a[2*i+1];
a[2*i+1]=a[2*i+2];
a[2*i+2]=temp;
}
}
}
}
int main()
{
int a[n]={2,1,4,9,5,3,6,10};
int *da;
cudaMalloc((void**)&da,n*sizeof(int));
cudaMemcpy(da,&a,n*sizeof(int),cudaMemcpyHostToDevice);
sort<<<1,n>>>(da);
cudaMemcpy(&a,da,n*sizeof(int),cudaMemcpyDeviceToHost);
printf("Sorted Order: ");
for(int i=0;i<n;i++)
printf("%d ",a[i]);
return 0;
}



dot product:

#include<stdio.h>
#include<cuda.h>

_global_ void dot(int *a, int *b, int *c, int nx, int ny){
int k = threadIdx.x;
c[k] = a[k] * b[k];
}

_global_ void red(int * c){
int t = threadIdx.x;
for(int a = 1; a < blockDim.x; a *= 2){
if(t % ( 2*a) == 0 && t+a < blockDim.x){
c[t] += c[t+a];
}
}
}

int main(){
int a[4] = {1, 2, 3, 4};
int b[4] = {1, 2, 3, 4};
int c[4] = {0, 0, 0, 0};

int *da, *db, *dc, size = 4*sizeof(int);
cudaMalloc((void **) & da, size);
cudaMemcpy(da, a, size, cudaMemcpyHostToDevice);
cudaMalloc((void **)&db, size);
cudaMemcpy(db, b, size, cudaMemcpyHostToDevice);
cudaMalloc((void **)&dc, size);
cudaMemcpy(dc, c, size, cudaMemcpyHostToDevice);
dot<<<1,4>>>(da, db, dc, 1, 4);
red<<<1,4>>>(dc);
cudaMemcpy(&c, dc, size, cudaMemcpyDeviceToHost);
printf("%d", c[0]);
return 0;
}


parallel reduction product:

#include<cuda.h>
#include<stdio.h>

_global_ void pararedn(int* a){
int t = threadIdx.x;
for(int j = 1; j < blockDim.x; j*=2){
if(t % (2*j) == 0 && (t+j) < blockDim.x){
a[t] = a[t] * a[t+j];
}
//printf("%d ", a[t]);
}
}

int main() {
int arr[10];
for(int i = 0; i < 10; i++) {
arr[i] = i+1;
}
for(int i = 0; i < 10; i++){
printf("%d", arr[i]);
}
int *in;
cudaMalloc((void**)&in, 10*sizeof(int));
cudaMemcpy(in, &arr, 10 * sizeof(int), cudaMemcpyHostToDevice);
//cudaMemcpy(out, &sol, 6 * sizeof(int), cudaMemcpyHostToDevice);
printf("before call\n");
pararedn<<<1, 10>>>(in);
printf("after call\n");
cudaMemcpy(&arr, in, 10*sizeof(int), cudaMemcpyDeviceToHost);
printf("%d\n", arr[0]);
cudaFree(in);
//cudaFree(out);
}


Matrix transpose : 
#include<stdio.h>
#include<cuda.h>

_global_ void trans(int *in, int *out, int nx, int ny) {
// static shared memory
_shared_ int tile[2][2];
// coordinate in original matrix
unsigned int ix,iy,ti,to;
ix = blockIdx.x *blockDim.x + threadIdx.x;
iy = blockIdx.y *blockDim.y + threadIdx.y;
// linear global memory index for original matrix
ti = iy*nx + ix;
// thread index in transposed block
unsigned int bidx,irow,icol;
bidx = threadIdx.y*blockDim.x + threadIdx.x;
irow = bidx/blockDim.y;
icol = bidx%blockDim.y;
// coordinate in transposed matrix
ix = blockIdx.y * blockDim.y + icol;
iy = blockIdx.x * blockDim.x + irow;
// linear global memory index for transposed matrix
to = iy*ny + ix;
// transpose with boundary test
if (ix < nx && iy < ny)
{
// load data from global memory to shared memory
tile[threadIdx.y][threadIdx.x] = in[ti];
// thread synchronization
__syncthreads();
// store data to global memory from shared memory
out[to] = tile[icol][irow];
}
}

int main(){
int a[4][4] = {{1, 2, 3, 4}, {3, 4, 5, 6}, {5, 6, 7, 8}, {7, 8, 9, 10}};
int res[4][4] = {{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};
int *da;
int *dc;
cudaMalloc((void*)&da, 4 4*sizeof(int));
cudaMalloc((void*)&dc, 4 4*sizeof(int));
cudaMemcpy(da, &a, 4 *4*sizeof(int), cudaMemcpyHostToDevice);
cudaMemcpy(dc, &res, 4 *4*sizeof(int), cudaMemcpyHostToDevice);
dim3 grid(4, 4);
dim3 block(4, 4);
printf("before transpose: \n");
for(int i = 0; i < 4; i++){
for(int j = 0; j< 4; j++) {
printf("%d ", a[i][j]);
}
printf("\n");
}
trans<<<grid, block>>>(da, dc, 4, 4);
//a[y * row + x] = p[y*col + x];
cudaMemcpy(&res, dc, 4*4*sizeof(int), cudaMemcpyDeviceToHost);
printf("after transpose: \n");
for(int i = 0; i < 4; i++){
for(int j = 0; j< 4; j++) {
printf("%d ", res[i][j]);
}
printf("\n");
}
cudaFree(da);
cudaFree(dc);
}



#include<stdio.h>
#include<cuda.h>

_global_ void dot(int *a){
int k = threadIdx.x;
a[k] = k + 1;
printf("%d", a[k]);
}

_global_ void red(int *c){
int t = threadIdx.x;
for(int a = 1; a < blockDim.x; a *= 2){
if(t % ( 2*a) == 0 && (t+a) < blockDim.x){
c[t] *= c[t+a];
}
}
printf("%d ", c[t]);
}

int main(){
int n = 0;
printf("Enter the number:\n");
scanf("%d", &n);
if(n < 0){
printf("negative, not possible.\n");
return 0;
}
int c[n];
for(int i = 0; i < n; i++){
c[i] = 1;
}
int *da, size = n*sizeof(int);
cudaMalloc((void **) & da, size);
//cudaMemcpy(da, a, size, cudaMemcpyHostToDevice);
//cudaMalloc((void **)&db, size);
//cudaMemcpy(db, b, size, cudaMemcpyHostToDevice);
//cudaMalloc((void **)&dc, size);
//cudaMemcpy(dc, c, size, cudaMemcpyHostToDevice);
dot<<<1,n>>>(da);
red<<<1,n>>>(da);
cudaMemcpy(&c, da, size, cudaMemcpyDeviceToHost);
printf("Dot Product :%d ",c);
for(int i = 0; i < 4; i++){
printf("%d  ", c[i]);
}
printf("%d", c[0]);
return 0;
}
